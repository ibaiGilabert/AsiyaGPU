Generate .o:

	$g++ -c Common.cpp
	$g++ -c Asiya.cpp


Link and generate executable:

	$g++ -o Asiya Asiya.o Common.o


Linking Reference bin libraries:

	#include <boost/regex.hpp>				->		-lboos_regex
	#include <boost/filesystem.hpp>			->		-lboost_system -lboost_filesystem



XML PARSER

	Install:

		$apt-get intall libxml2-dev

	Compile:

		$g++ libxml.cpp -o libxml -lxml2 -I/usr/include/libxml2


	EXEMPLE useful de construcció del document xml: writer_newxml.cpp



AXIOMES:

	undef de perl és equivalent a -1


REVISAR:

	Config.cpp -> Obtenció de "SYSTEM" del fitxer de configuració. (sub process_config_file)

	Config.cpp -> Les funcions process_nist_file i process_raw_file estan incompletes. (dependència NISTXML.pm)

	Config.cpp -> sizes dels scalar(rIDX) (el sospitós -1)

	Core.cpp -> Creació de la TSDatabase (do_score)

	Scores.cpp -> La puntuació de l'atribut "all" de scores és -1 en comptes de {} en l'original %hOQ.

	Core.cpp ->	HREF pot ser un hash multiple (del(s?) references files)

	Config.cpp	->	validate_configuration inacabat

SHORTCUTS

	-->IF file exists
	#include <boost/filesystem.hpp>

	  boost::filesystem::path p (TOOLS);   // p reads clearer than argv[1] in the following code

	  if (exists(p))    // does p actually exist?
	  {
	    if (is_regular_file(p))        // is p a regular file?
	      cout << p << " size is " << file_size(p) << '\n';

	    else if (is_directory(p))      // is p a directory?
   		   cout << p << " is a directory\n";


	-->SPLIT string

    boost::regex reeq(" ");
    boost::sregex_token_iterator i(entry.second.begin(), entry.second.end(), reeq, -1);
    boost::sregex_token_iterator j;
    while (i != j) {
        Config::systems.insert(*i++);
    }

    	//MILLOR ALTERNATIVA

    	#include <boost/algorithm/string.hpp>
		std::vector<std::string> strs;
		boost::split(strs, "string to split", boost::is_any_of("\t "));



TODO LIST
	-	LOCAL	->	Provar la creacio de fitxers SGML_f_ (es a dir, provar el parser joder)